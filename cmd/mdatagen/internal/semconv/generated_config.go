// Code generated by github.com/atombender/go-jsonschema, DO NOT EDIT.

package semconv

import (
	"encoding/json"
	"fmt"
	"reflect"
)

type AnyValueSemanticConvention struct {
	// a brief description of the value.
	Brief *string `json:"brief,omitempty" yaml:"brief,omitempty" mapstructure:"brief,omitempty"`

	// Deprecated corresponds to the JSON schema field "deprecated".
	Deprecated AnyValueSemanticConventionDeprecated `json:"deprecated,omitempty" yaml:"deprecated,omitempty" mapstructure:"deprecated,omitempty"`

	// sequence/dictionary of example values. They are optional for boolean, int,
	// double, and enum attributes. Example values must be of the same type as the
	// value. If only a single example is provided, it can directly be reported
	// without encapsulating it into a sequence/dictionary.
	Examples []AnyValueSemanticConventionExamples_0Elem `json:"examples,omitempty" yaml:"examples,omitempty" mapstructure:"examples,omitempty"`

	// when the type is map, this identifies the child (nested) any values associated
	// with the map.
	Fields []AnyValueSemanticConvention `json:"fields,omitempty" yaml:"fields,omitempty" mapstructure:"fields,omitempty"`

	// unique string
	Id string `json:"id" yaml:"id" mapstructure:"id"`

	// when the type is enum, this identifies the enum members.
	Members []AnyValueSemanticConventionMembersElem `json:"members,omitempty" yaml:"members,omitempty" mapstructure:"members,omitempty"`

	// a more elaborate description of the value. It defaults to an empty string.
	Note *string `json:"note,omitempty" yaml:"note,omitempty" mapstructure:"note,omitempty"`

	// specifies the any value requirement level. Can be 'required',
	// 'conditionally_required', 'recommended', or 'opt_in'. When omitted, the value
	// is 'recommended'. When set to 'conditionally_required', the string provided
	// MUST specify the conditions under which the value is required.
	RequirementLevel interface{} `json:"requirement_level" yaml:"requirement_level" mapstructure:"requirement_level"`

	// Stability corresponds to the JSON schema field "stability".
	Stability interface{} `json:"stability" yaml:"stability" mapstructure:"stability"`

	// Type corresponds to the JSON schema field "type".
	Type AnyValueSemanticConventionType `json:"type" yaml:"type" mapstructure:"type"`
}

type AnyValueSemanticConventionDeprecated interface{}

type AnyValueSemanticConventionExamples_0Elem interface{}

type AnyValueSemanticConventionMembersElem struct {
	// brief description of the enum entry value. It defaults to the value of ID.
	Brief *string `json:"brief,omitempty" yaml:"brief,omitempty" mapstructure:"brief,omitempty"`

	// Deprecated corresponds to the JSON schema field "deprecated".
	Deprecated AnyValueSemanticConventionMembersElemDeprecated `json:"deprecated,omitempty" yaml:"deprecated,omitempty" mapstructure:"deprecated,omitempty"`

	// string unique
	Id string `json:"id" yaml:"id" mapstructure:"id"`

	// longer description. It defaults to an empty string.
	Note *string `json:"note,omitempty" yaml:"note,omitempty" mapstructure:"note,omitempty"`

	// Stability corresponds to the JSON schema field "stability".
	Stability interface{} `json:"stability" yaml:"stability" mapstructure:"stability"`

	// string or number, value of the enum entry.
	Value interface{} `json:"value" yaml:"value" mapstructure:"value"`
}

type AnyValueSemanticConventionMembersElemDeprecated interface{}

// UnmarshalJSON implements json.Unmarshaler.
func (j *AnyValueSemanticConventionMembersElem) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["id"]; raw != nil && !ok {
		return fmt.Errorf("field id in AnyValueSemanticConventionMembersElem: required")
	}
	if _, ok := raw["stability"]; raw != nil && !ok {
		return fmt.Errorf("field stability in AnyValueSemanticConventionMembersElem: required")
	}
	if _, ok := raw["value"]; raw != nil && !ok {
		return fmt.Errorf("field value in AnyValueSemanticConventionMembersElem: required")
	}
	type Plain AnyValueSemanticConventionMembersElem
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = AnyValueSemanticConventionMembersElem(plain)
	return nil
}

type AnyValueSemanticConventionType interface{}

// UnmarshalJSON implements json.Unmarshaler.
func (j *AnyValueSemanticConvention) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["id"]; raw != nil && !ok {
		return fmt.Errorf("field id in AnyValueSemanticConvention: required")
	}
	if _, ok := raw["requirement_level"]; raw != nil && !ok {
		return fmt.Errorf("field requirement_level in AnyValueSemanticConvention: required")
	}
	if _, ok := raw["stability"]; raw != nil && !ok {
		return fmt.Errorf("field stability in AnyValueSemanticConvention: required")
	}
	if _, ok := raw["type"]; raw != nil && !ok {
		return fmt.Errorf("field type in AnyValueSemanticConvention: required")
	}
	type Plain AnyValueSemanticConvention
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = AnyValueSemanticConvention(plain)
	return nil
}

// specifies the supported any value types.
type AnyValueType interface{}

type Attribute interface{}

type AttributeEnumType struct {
	// Members corresponds to the JSON schema field "members".
	Members []AttributeEnumTypeMembersElem `json:"members,omitempty" yaml:"members,omitempty" mapstructure:"members,omitempty"`
}

type AttributeEnumTypeMembersElem struct {
	// Annotations corresponds to the JSON schema field "annotations".
	Annotations map[string]interface{} `json:"annotations,omitempty" yaml:"annotations,omitempty" mapstructure:"annotations,omitempty"`

	// brief description of the enum entry value. It defaults to the value of ID.
	Brief *string `json:"brief,omitempty" yaml:"brief,omitempty" mapstructure:"brief,omitempty"`

	// Deprecated corresponds to the JSON schema field "deprecated".
	Deprecated AttributeEnumTypeMembersElemDeprecated `json:"deprecated,omitempty" yaml:"deprecated,omitempty" mapstructure:"deprecated,omitempty"`

	// string unique
	Id string `json:"id" yaml:"id" mapstructure:"id"`

	// longer description. It defaults to an empty string.
	Note *string `json:"note,omitempty" yaml:"note,omitempty" mapstructure:"note,omitempty"`

	// Stability corresponds to the JSON schema field "stability".
	Stability interface{} `json:"stability" yaml:"stability" mapstructure:"stability"`

	// string or number, value of the enum entry.
	Value interface{} `json:"value" yaml:"value" mapstructure:"value"`
}

type AttributeEnumTypeMembersElemDeprecated interface{}

// UnmarshalJSON implements json.Unmarshaler.
func (j *AttributeEnumTypeMembersElem) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["id"]; raw != nil && !ok {
		return fmt.Errorf("field id in AttributeEnumTypeMembersElem: required")
	}
	if _, ok := raw["stability"]; raw != nil && !ok {
		return fmt.Errorf("field stability in AttributeEnumTypeMembersElem: required")
	}
	if _, ok := raw["value"]; raw != nil && !ok {
		return fmt.Errorf("field value in AttributeEnumTypeMembersElem: required")
	}
	type Plain AttributeEnumTypeMembersElem
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = AttributeEnumTypeMembersElem(plain)
	return nil
}

type AttributeFullSpec interface{}

type AttributeReference struct {
	// reference an existing attribute
	Ref string `json:"ref" yaml:"ref" mapstructure:"ref"`

	// associates a tag to the attribute
	Tag *string `json:"tag,omitempty" yaml:"tag,omitempty" mapstructure:"tag,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *AttributeReference) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["ref"]; raw != nil && !ok {
		return fmt.Errorf("field ref in AttributeReference: required")
	}
	type Plain AttributeReference
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = AttributeReference(plain)
	return nil
}

// specified the role of an attribute (e.g. descriptive or identifying).
type AttributeRole interface{}

// specifies the supported attribute types.
type AttributeType interface{}

// Specifies if an attribute or a signal is deprecated.
type Deprecated interface{}

// list of entity associations.
type EntityAssociation []string

type EntitySemanticConvention interface{}

type EventSemanticConvention interface{}

type MetricSemanticConvention interface{}

// YAML schema for semantic convention generator, use for example with VS Code.
type SchemaJson struct {
	// Groups corresponds to the JSON schema field "groups".
	Groups []interface{} `json:"groups,omitempty" yaml:"groups,omitempty" mapstructure:"groups,omitempty"`

	// Imports corresponds to the JSON schema field "imports".
	Imports *SchemaJsonImports `json:"imports,omitempty" yaml:"imports,omitempty" mapstructure:"imports,omitempty"`
}

type SchemaJsonImports struct {
	// Entities corresponds to the JSON schema field "entities".
	Entities []string `json:"entities,omitempty" yaml:"entities,omitempty" mapstructure:"entities,omitempty"`

	// Events corresponds to the JSON schema field "events".
	Events []string `json:"events,omitempty" yaml:"events,omitempty" mapstructure:"events,omitempty"`

	// Metrics corresponds to the JSON schema field "metrics".
	Metrics []string `json:"metrics,omitempty" yaml:"metrics,omitempty" mapstructure:"metrics,omitempty"`
}

type SemanticConvention interface{}

type SemanticConventionBase interface{}

type SemanticConventionBaseDeprecated interface{}

type SemanticConventionBaseType string

const SemanticConventionBaseTypeAttributeGroup SemanticConventionBaseType = "attribute_group"
const SemanticConventionBaseTypeEntity SemanticConventionBaseType = "entity"
const SemanticConventionBaseTypeEvent SemanticConventionBaseType = "event"
const SemanticConventionBaseTypeMetric SemanticConventionBaseType = "metric"
const SemanticConventionBaseTypeSpan SemanticConventionBaseType = "span"

var enumValues_SemanticConventionBaseType = []interface{}{
	"span",
	"entity",
	"metric",
	"event",
	"attribute_group",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SemanticConventionBaseType) UnmarshalJSON(value []byte) error {
	var v string
	if err := json.Unmarshal(value, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_SemanticConventionBaseType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_SemanticConventionBaseType, v)
	}
	*j = SemanticConventionBaseType(v)
	return nil
}

type SpanSemanticConvention interface{}

type StabilityLevel string

const StabilityLevelAlpha StabilityLevel = "alpha"
const StabilityLevelBeta StabilityLevel = "beta"
const StabilityLevelDevelopment StabilityLevel = "development"
const StabilityLevelReleaseCandidate StabilityLevel = "release_candidate"
const StabilityLevelStable StabilityLevel = "stable"

var enumValues_StabilityLevel = []interface{}{
	"stable",
	"development",
	"alpha",
	"beta",
	"release_candidate",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *StabilityLevel) UnmarshalJSON(value []byte) error {
	var v string
	if err := json.Unmarshal(value, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_StabilityLevel {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_StabilityLevel, v)
	}
	*j = StabilityLevel(v)
	return nil
}

type ValueType interface{}
