// Copyright The OpenTelemetry Authors
// SPDX-License-Identifier: Apache-2.0

package internal // import "go.opentelemetry.io/collector/cmd/mdatagen/internal"

import (
	"encoding/json"
	"fmt"
	"os"
	"path/filepath"

	"github.com/atombender/go-jsonschema/pkg/generator"
	"github.com/atombender/go-jsonschema/pkg/schemas"
	"github.com/golangci/golangci-lint/pkg/config"
	"github.com/golangci/golangci-lint/pkg/goformatters/goimports"
	"mvdan.cc/gofumpt/format"
)

const (
	ConfigName       = "config"
	ConfigOutputFile = "generated_config.go"
)

// GenerateConfig generates a "generated_config.go", as well as any other Go files which "generated_config.go" depends on.
// The inputs are:
// * "goPkgName" is the Go package at the top of the "generated_config.go" file. For example, "batchprocessor".
// * "dir" is the location where the "config.go" file will be written. For example, "./processor/batchprocessor".
// * "conf" is the schema for "generated_config.go". It is a "map[string]any".
//
// The output is a map, where:
// * The key is the absolute path to the file which must be written.
// * The value is the content of the file.
func GenerateConfig(goPkgName, dir string, conf any, cfgSources []ConfigSource) (map[string]string, error) {
	// load config
	jsonBytes, err := json.Marshal(conf)
	if err != nil {
		return nil, fmt.Errorf("failed loading config %w", err)
	}
	var schema schemas.Schema
	if err = json.Unmarshal(jsonBytes, &schema); err != nil {
		return nil, fmt.Errorf("failed to unmarshal JSON: %w", err)
	}

	defaultOutputDir, err := filepath.Abs(dir)
	if err != nil {
		return nil, fmt.Errorf("failed to get absolute path for %s: %w", dir, err)
	}
	defaultOutputNameDest := filepath.Join(defaultOutputDir, ConfigOutputFile)

	// TODO: Make this configurable?
	repoRootDir := "../../"

	schemaMappings := []generator.SchemaMapping{}
	for _, cfgSource := range cfgSources {
		schemaMappings = append(schemaMappings, generator.SchemaMapping{
			SchemaID:    cfgSource.SchemaID,
			PackageName: cfgSource.PackageName,
			OutputName:  cfgSource.OutputName,
		})
	}
	for i := range schemaMappings {
		if schemaMappings[i].OutputName != "" {
			// The file paths in the schema mappings are relative to the repo root.
			// Make the paths absolute.
			relFilePath := filepath.Clean(filepath.Join(repoRootDir, schemaMappings[i].OutputName))
			absFilePath, errAbs := filepath.Abs(relFilePath)
			if errAbs != nil {
				return nil, fmt.Errorf("failed to get absolute path for %s: %w", schemaMappings[i].OutputName, err)
			}
			absFilePath = filepath.Clean(absFilePath)
			schemaMappings[i].OutputName = absFilePath
		}
	}

	cfg := generator.Config{
		Warner: func(message string) {
			logf("Warning: %s", message)
		},
		DefaultPackageName:  goPkgName,
		DefaultOutputName:   defaultOutputNameDest,
		StructNameFromTitle: true,
		Tags:                []string{"mapstructure"},
		SchemaMappings:      schemaMappings,
		YAMLExtensions:      []string{".yaml", ".yml"},
		DisableOmitempty:    true,
	}

	generator, err := generator.New(cfg)
	if err != nil {
		return nil, fmt.Errorf("failed to create generator: %w", err)
	}
	if err = generator.AddFile(ConfigName, &schema); err != nil {
		return nil, fmt.Errorf("failed to add config: %w", err)
	}

	output := make(map[string]string)
	sources, err := generator.Sources()
	if err != nil {
		return nil, fmt.Errorf("failed to generate Go files from schema: %w", err)
	}
	for sourceName, source := range sources {
		source, err = formatSource(source)
		if err != nil {
			return nil, fmt.Errorf("failed to format source for %s: %w", sourceName, err)
		}

		fmt.Printf("Generated file %s\n", sourceName)
		output[sourceName] = string(source)
	}
	fmt.Println("done")
	return output, nil
}

func logf(format string, args ...any) {
	fmt.Fprint(os.Stderr, "go-jsonschema: ")
	fmt.Fprintf(os.Stderr, format, args...)
	fmt.Fprint(os.Stderr, "\n")
}

// Format the source code using linting and formatting tools.
// This prevents issues with IDEs reformating the autogenerated code if someone opens them.
//
// For example, IDEs may want to change this...
// import "encoding/json"
// import "fmt"
//
// ...to this...
//
// import (
//
//	"encoding/json"
//	"fmt"
//
// )
func formatSource(source []byte) ([]byte, error) {
	var err error

	source, err = format.Source(source, format.Options{ExtraRules: true})
	if err != nil {
		return nil, fmt.Errorf("failed to format source for %s: %w", source, err)
	}

	// Running goimmports fixes further linting issues, such as grouping imports
	// into std and non-std groups.
	importsFormatter := goimports.New(&config.GoImportsSettings{})
	source, err = importsFormatter.Format("", source)
	if err != nil {
		return nil, fmt.Errorf("failed to format imports for %s: %w", source, err)
	}

	return source, nil
}
