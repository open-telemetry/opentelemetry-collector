// Code generated by mdatagen. DO NOT EDIT.

package metadata

import (
	"errors"
	"fmt"
	"io"
	"sort"
	"strings"
	"unicode"
)

func expandPatternMap(patternMap map[string]any, matchNames []string) (map[string]any, error) {
	patterns := patternBlocks{}

	patternStrBlocks := []patternStringBlock{}
	for patternStr, data := range patternMap {
		patternStrBlocks = append(patternStrBlocks, patternStringBlock{
			ptStr: patternStr,
			data:  data,
		})
	}

	for _, patternStrBlock := range patternStrBlocks {
		patternBlock, err := patternBlockFromStringBlock(patternStrBlock)
		if err != nil {
			return nil, err
		}
		patterns.add(patternBlock)
	}

	expandedMap, err := matchAllPatterns(patterns, matchNames)
	if err != nil {
		return nil, err
	}

	return expandedMap, nil
}

type groupType int

const (
	groupWildcard groupType = iota
	groupMultimatch
	groupIdentifier
)

type group struct {
	typ    groupType
	values []string
}

type pattern struct {
	originalStr string
	groups      []group
}

func newPatternFromString(str string) (*pattern, error) {
	p := &parser{str: str}
	return p.parse()
}

type parser struct {
	str string
	idx int
}

func (p *parser) parse() (*pattern, error) {
	// parse:
	pt := &pattern{originalStr: p.str}
	var parseErr error
parseLoop:
	for !p.isFinished() {
		curr, err := p.current()
		if err != nil {
			break
		}
		switch curr {
		case '*':
			g, err := p.parseWildcard()
			if err != nil {
				parseErr = err
				break parseLoop
			}
			pt.groups = append(pt.groups, g)
		case '{':
			g, err := p.parseMultimatch()
			if err != nil {
				parseErr = err
				break parseLoop
			}
			pt.groups = append(pt.groups, g)
		default:
			identifier, err := p.parseIdentifier()
			if err != nil {
				parseErr = err
				break parseLoop
			}

			pt.groups = append(
				pt.groups,
				group{typ: groupIdentifier, values: []string{identifier}},
			)
		}

		// After a valid group, only a '.' and another group
		// or end of input are valid.
		if !p.isFinished() {
			curr, _ := p.current()
			if curr != '.' {
				parseErr = p.parseError(errUnexpectedToken)
				break parseLoop
			}
			p.idx++
			if p.isFinished() {
				parseErr = p.parseError(errUnexpectedEndOfInput)
				break parseLoop
			}
		}
	}

	return pt, parseErr
}

func (p *parser) parseWildcard() (group, error) {
	// If a wildcard is found, the only valid next steps
	// are a group separator or the end of the pattern.

	curr, err := p.current()
	if err != nil {
		return group{}, p.internalError(errUnexpectedEndOfInput)
	}
	if curr != '*' {
		return group{}, p.internalError(errUnexpectedToken)
	}

	p.idx++
	return group{typ: groupWildcard}, nil
}

func (p *parser) parseMultimatch() (group, error) {
	// A multimatch is defined by this rule in EBNF:
	//
	// multimatch: '{' (otel_identifier ((',' ' '*)? otel_identifier)*) '}'
	//
	// It is a comma-separated list of identifiers enclosed in braces.
	// It cannot be empty.
	// Whitespace after a comma is allowed and has no significance.

	// Consume the opening brace.
	curr, err := p.current()
	if err != nil {
		return group{}, p.internalError(errUnexpectedEndOfInput)
	}
	if curr != '{' {
		return group{}, p.internalError(errUnexpectedToken)
	}
	p.idx++

	var parseErr error
	identifiers := []string{}
parseLoop:
	for !p.isFinished() {
		curr, err := p.current()
		if err != nil {
			parseErr = p.parseError(errUnexpectedEndOfInput)
			break
		}

		switch curr {
		case '}':
			// The multimatch is complete.
			p.idx++
			break parseLoop
		case ',':
			// After a comma, only whitespace or the start of an identifier
			// (a CHARACTER) is valid.
			p.idx++
			curr, err := p.current()
			if err != nil {
				parseErr = p.parseError(errUnexpectedEndOfInput)
				break parseLoop
			}
			if curr != ' ' && !validIdentifierChar(curr) {
				parseErr = p.parseError(errUnexpectedToken)
				break parseLoop
			}
		case ' ':
			// Whitespace is silently consumed.
			p.idx++
		default:
			if !validIdentifierChar(curr) {
				parseErr = p.parseError(errUnexpectedToken)
				break parseLoop
			}
			identifier, err := p.parseIdentifier()
			if err != nil {
				parseErr = err
				break parseLoop
			}
			identifiers = append(identifiers, identifier)
		}
	}

	if len(identifiers) == 0 {
		parseErr = p.parseError(errEmptyMultimatch)
	}

	return group{
		typ:    groupMultimatch,
		values: identifiers,
	}, parseErr
}

func (p *parser) parseIdentifier() (string, error) {
	// An identifier is defined by this rule in EBNF:
	//
	// otel_identifier: CHARACTER (UNDERSCORE? CHARACTER)*
	//
	// It can only contain characters and underscores, and cannot
	// start or end with an underscore.
	var identifier string
	var parseErr error

	// Consume the starting CHARACTER.
	curr, err := p.current()
	if err != nil {
		return "", p.internalError(errUnexpectedEndOfInput)
	}
	if !validIdentifierChar(curr) {
		return "", p.parseError(errStartAlphabetic)
	}
	p.idx++

	identifier += string(curr)

	// Consume the rest of the identifier with the following procedure:
	//
	// If a character is found, add it to the identifier.
	//
	// If an underscore is found, add it to the identifier and consume the next
	// token ensuring it is a character.
	//
	// If any other character or the end of input is found, assume the identifier
	// is complete.
	for !p.isFinished() {
		curr, err := p.current()
		if err != nil {
			break
		}

		if validIdentifierChar(curr) {
			identifier += string(curr)
			p.idx++
			continue
		}
		if curr == '_' {
			identifier += string(curr)
			p.idx++
			afterUnderscore, err := p.current()
			if err != nil {
				parseErr = p.parseError(errUnexpectedEndOfInput)
				break
			}
			if validIdentifierChar(afterUnderscore) {
				identifier += string(afterUnderscore)
				p.idx++
				continue
			} else {
				parseErr = p.parseError(errUnexpectedToken)
				break
			}
		}

		break
	}

	return identifier, parseErr
}

func (p *parser) current() (rune, error) {
	if p.isFinished() {
		return 0, io.EOF
	}

	return rune(p.str[p.idx]), nil
}

func (p *parser) isFinished() bool {
	return p.idx >= len(p.str)
}

func (p *parser) parseError(err error) error {
	return &patternParseError{
		p:   p.str,
		idx: p.idx,
		err: fmt.Errorf("invalid pattern: %w", err),
	}
}

func (p *parser) internalError(err error) error {
	return &patternParseError{
		p:   p.str,
		idx: p.idx,
		err: fmt.Errorf("internal parser error: %w", err),
	}
}

func validIdentifierChar(c rune) bool {
	return unicode.IsLetter(c) || unicode.IsDigit(c)
}

var (
	errUnexpectedEndOfInput = errors.New("unexpected end of input")
	errUnexpectedToken      = errors.New("unexpected token")
	errEmptyMultimatch      = errors.New("empty multimatch")
	errStartAlphabetic      = errors.New("identifier must start with an alphabetic character")
)

type patternParseError struct {
	p   string
	idx int
	err error
}

func (e *patternParseError) Error() string {
	msg := "pattern parsing error:\n"
	msg += e.p + "\n"
	msg += strings.Repeat(" ", e.idx) + "^" + "\n"
	msg += e.err.Error()
	return msg
}

type patternStringBlock struct {
	ptStr string
	data  any
}

type patternBlock struct {
	pt   *pattern
	data any
}

func patternBlockFromStringBlock(pb patternStringBlock) (patternBlock, error) {
	pt, err := newPatternFromString(pb.ptStr)
	if err != nil {
		return patternBlock{}, err
	}
	return patternBlock{
		pt:   pt,
		data: pb.data,
	}, nil
}

type patternBlocks []patternBlock

func (pbs *patternBlocks) add(pb patternBlock) {
	newPbs := append(*pbs, pb)
	sort.SliceStable(newPbs, func(i, j int) bool {
		// The pattern with less groups will be applied first.
		if len(newPbs[i].pt.groups) != len(newPbs[j].pt.groups) {
			return len(newPbs[i].pt.groups) < len(newPbs[j].pt.groups)
		}

		// Checking if one has a matcher and one doesn't, or one has an
		// earlier matcher than another.
		earliestMatcherI := -1
		earliestMatcherJ := -1
		for groupIdx := 0; groupIdx < len(newPbs[i].pt.groups); groupIdx++ {
			iGroup := newPbs[i].pt.groups[groupIdx]
			jGroup := newPbs[j].pt.groups[groupIdx]

			if (iGroup.typ == groupWildcard || iGroup.typ == groupMultimatch) && earliestMatcherI == -1 {
				earliestMatcherI = groupIdx
			}

			if (jGroup.typ == groupWildcard || jGroup.typ == groupMultimatch) && earliestMatcherJ == -1 {
				earliestMatcherJ = groupIdx
			}
		}

		// If neither has a matcher, jump to lexicographic ordering.
		if earliestMatcherI == -1 && earliestMatcherJ == -1 {
			goto lexicographic
		}

		// If one has a matcher and one doesn't, that will be applied first.
		if earliestMatcherI != -1 && earliestMatcherJ == -1 {
			return true
		}
		if earliestMatcherJ != -1 && earliestMatcherI == -1 {
			return false
		}

		// If they both have matchers but aren't the same, the pattern with the
		// earlier matcher will be applied first.
		if earliestMatcherI != earliestMatcherJ {
			return earliestMatcherI < earliestMatcherJ
		}

		// If they both have their earliest matchers at the same index,
		// wildcards are applied first.
		if newPbs[i].pt.groups[earliestMatcherI].typ != newPbs[j].pt.groups[earliestMatcherJ].typ {
			return newPbs[i].pt.groups[earliestMatcherI].typ == groupWildcard
		}

	lexicographic:
		// If the earliest present matcher is the same, the final sorting is determined
		// lexicographically.
		return strings.Compare(newPbs[i].pt.originalStr, newPbs[j].pt.originalStr) < 0
	})
	*pbs = newPbs
}

func matchAllPatterns(patterns patternBlocks, names []string) (map[string]any, error) {
	matchedNameData := map[string]any{}
	for _, patternBlock := range patterns {
		matches, err := matchNames(patternBlock.pt, names)
		if err != nil {
			return nil, err
		}
		for _, match := range matches {
			matchedNameData[match] = patternBlock.data
		}
	}
	return matchedNameData, nil
}

func matchNames(p *pattern, names []string) ([]string, error) {
	matches := []string{}
	for _, nameStr := range names {
		name, err := newPatternFromString(nameStr)
		if err != nil {
			return nil, err
		}

		pGroupIdx := 0
		matched := true
		for nameGroupIdx, nameGroup := range name.groups {
			currPatternGroup := p.groups[pGroupIdx]
			if matchGroup(currPatternGroup, nameGroup) {
				if pGroupIdx == len(p.groups)-1 { // If this is the last group in the pattern
					// If this last group is not a wildcard
					if currPatternGroup.typ != groupWildcard {
						// Check that we are at the last group in the name, if
						// we are not then the match fails.
						if nameGroupIdx != len(name.groups)-1 {
							matched = false
							break
						}
					}
				} else if nameGroupIdx == len(name.groups)-1 { // If this is the last group in the name but not the pattern
					matched = false
					break
				} else { // Otherwise move to the next group in the patter
					pGroupIdx++
				}
			} else {
				matched = false
				break
			}
		}
		if matched {
			matches = append(matches, nameStr)
		}
	}

	return matches, nil
}

func matchGroup(patternGroup, matchGroup group) bool {
	switch patternGroup.typ {
	case groupWildcard:
		return true
	case groupMultimatch:
		for _, value := range patternGroup.values {
			if value == matchGroup.values[0] {
				return true
			}
		}
	case groupIdentifier:
		return patternGroup.values[0] == matchGroup.values[0]
	}

	return false
}
