// Copyright The OpenTelemetry Authors
// SPDX-License-Identifier: Apache-2.0

package arc // import "go.opentelemetry.io/collector/exporter/exporterhelper/internal/arc"

import (
	"context"
	"math"
	"sync"
	"time"

	"go.opentelemetry.io/otel/attribute"
	"go.opentelemetry.io/otel/metric"

	"go.opentelemetry.io/collector/component"
	"go.opentelemetry.io/collector/exporter/exporterhelper/internal/metadata"
	"go.opentelemetry.io/collector/pipeline"
)

// Controller coordinates ARC. Internally it uses a control law and a TokenPool gate.
type Controller struct {
	cfg  Config
	pool *TokenPool

	// Telemetry builder (generated by metadata) and instruments.
	tel              *metadata.TelemetryBuilder
	rttInst          metric.Int64Histogram
	failuresInst     metric.Int64Counter
	limitChangesInst metric.Int64Counter
	limitUpAttrs     metric.MeasurementOption
	limitDownAttrs   metric.MeasurementOption
	backoffInst      metric.Int64Counter
	syncAttrs        metric.MeasurementOption

	mu sync.Mutex
	st struct {
		limit       int
		inFlight    int
		credits     int  // ceiling-hit credits (for additive increase)
		pressure    bool // any explicit pressure in period
		periodStart time.Time
		periodDur   time.Duration
		reMean      robustEWMA // robust mean + absdev estimator for RTT
		prevRTTMean float64
		prevRTTDev  float64
		lastRTTMean float64
		lastRTTDev  float64
	}
}

// NewController creates a new ARC Controller.
func NewController(cfg Config, tel *metadata.TelemetryBuilder, id component.ID, signal pipeline.Signal) *Controller {
	def := DefaultConfig()
	if cfg.InitialLimit <= 0 {
		cfg.InitialLimit = 1
	}
	if cfg.MaxConcurrency <= 0 {
		cfg.MaxConcurrency = def.MaxConcurrency
	}
	if cfg.InitialLimit > cfg.MaxConcurrency {
		cfg.InitialLimit = cfg.MaxConcurrency
	}
	if cfg.DecreaseRatio <= 0 || cfg.DecreaseRatio >= 1 {
		cfg.DecreaseRatio = def.DecreaseRatio
	}
	if cfg.EwmaAlpha <= 0 || cfg.EwmaAlpha >= 1 {
		cfg.EwmaAlpha = def.EwmaAlpha
	}
	if cfg.DeviationScale < 0 {
		cfg.DeviationScale = def.DeviationScale
	}

	// Attributes used on emitted metrics.
	exporterAttr := attribute.String("exporter", id.String())
	dataTypeAttr := attribute.String("data_type", signal.String())
	syncAttrs := metric.WithAttributeSet(attribute.NewSet(exporterAttr, dataTypeAttr))
	limitUpAttrs := metric.WithAttributeSet(attribute.NewSet(
		exporterAttr, dataTypeAttr, attribute.String("direction", "up"),
	))
	limitDownAttrs := metric.WithAttributeSet(attribute.NewSet(
		exporterAttr, dataTypeAttr, attribute.String("direction", "down"),
	))

	c := &Controller{
		cfg:              cfg,
		pool:             newTokenPool(cfg.InitialLimit),
		tel:              tel,
		rttInst:          tel.ExporterArcRttMs,
		failuresInst:     tel.ExporterArcFailures,
		limitChangesInst: tel.ExporterArcLimitChanges,
		limitUpAttrs:     limitUpAttrs,
		limitDownAttrs:   limitDownAttrs,
		backoffInst:      tel.ExporterArcBackoffEvents,
		syncAttrs:        syncAttrs,
	}

	c.st.limit = cfg.InitialLimit
	c.st.reMean = newRobustEWMA(cfg.EwmaAlpha)
	c.st.periodStart = time.Now()
	c.st.periodDur = clampDur(minPeriod, maxPeriod, 300*time.Millisecond) // initial period

	// Register async gauges.
	_ = tel.RegisterExporterArcLimitCallback(func(_ context.Context, o metric.Int64Observer) error {
		o.Observe(int64(c.CurrentLimit()), syncAttrs)
		return nil
	})
	_ = tel.RegisterExporterArcPermitsInUseCallback(func(_ context.Context, o metric.Int64Observer) error {
		o.Observe(int64(c.PermitsInUse()), syncAttrs)
		return nil
	})

	return c
}

// controlStep applies the ARC control law at the end of a period.
// Caller must hold c.mu.
func (c *Controller) controlStep(ctx context.Context) {
	limitBefore := c.st.limit

	// If we don't have a prior baseline yet, treat RTT spike detection as disabled
	// (no isSpike) but still allow explicit-pressure decreases in cold start.
	hasBaseline := c.st.prevRTTMean > 0
	threshold := c.st.prevRTTMean + c.cfg.DeviationScale*c.st.prevRTTDev
	isSpike := hasBaseline && c.st.reMean.initialized() && c.st.lastRTTMean > threshold

	// Decrease on explicit pressure or RTT spike.
	if c.st.limit > 1 && (c.st.pressure || isSpike) {
		newLimit := int(math.Floor(float64(c.st.limit) * c.cfg.DecreaseRatio))
		if newLimit < 1 {
			newLimit = 1
		}
		if dec := c.st.limit - newLimit; dec > 0 {
			c.pool.Shrink(dec)
			c.st.limit = newLimit
			if c.tel != nil {
				if c.backoffInst != nil {
					c.backoffInst.Add(contextOrBG(ctx), 1, c.syncAttrs)
				}
				if c.limitChangesInst != nil && c.st.limit != limitBefore {
					c.limitChangesInst.Add(contextOrBG(ctx), 1, c.limitDownAttrs)
				}
			}
			c.st.credits = 0
			c.st.pressure = false
			return
		}
	}

	// Additive increase is *disabled* until we have a prior baseline (first roll).
	// This avoids a spurious +1 when tests "poke" the controller to roll the period.
	canIncreaseRTT := !c.st.reMean.initialized() || c.st.lastRTTMean <= threshold
	if hasBaseline && // <- require baseline to allow additive increase
		c.st.limit < c.cfg.MaxConcurrency &&
		!c.st.pressure &&
		c.st.credits >= requiredCredits(c.st.limit) &&
		canIncreaseRTT {
		c.pool.Grow(1)
		c.st.limit++
		if c.tel != nil && c.limitChangesInst != nil && c.st.limit != limitBefore {
			c.limitChangesInst.Add(contextOrBG(ctx), 1, c.limitUpAttrs)
		}
		c.st.credits = 0 // reset after successful increase
		return
	}

	// Modest credit decay if no change happened.
	c.st.credits = int(float64(c.st.credits) * 0.5)
	c.st.pressure = false
}

func (c *Controller) Shutdown() {
	if c == nil {
		return
	}
	if c.tel != nil {
		c.tel.Shutdown()
	}
	if c.pool != nil {
		c.pool.Close()
	}
}

// Acquire obtains a permit unless ARC is disabled or the context is cancelled.
func (c *Controller) Acquire(ctx context.Context) bool {
	// Fast-path bypass: if ARC is disabled, do not gate.
	if !c.cfg.Enabled {
		return true
	}
	// TokenPool.Acquire returns an error; return true when no error (permit obtained).
	return c.pool.Acquire(ctx) == nil
}

// Release returns a permit.
func (c *Controller) Release() { c.pool.Release() }

// ReleaseWithSample reports a sample (RTT + classification) and releases.
func (c *Controller) ReleaseWithSample(ctx context.Context, rtt time.Duration, success, backpressure bool) {
	c.Feedback(ctx, rtt, success, backpressure)
}

// StartRequest increments in-flight accounting and emits "in use" telemetry.
// Keep this as a no-op when disabled.
func (c *Controller) StartRequest() {
	if !c.cfg.Enabled {
		return
	}

	c.mu.Lock()
	// ===== existing in-flight++ and "reachedLimit" logic =====
	c.st.inFlight++
	if c.st.inFlight >= c.st.limit {
		// record a ceiling hit as a credit for additive increase logic
		c.st.credits++
	}
	// Emit "permits in use" observable via tel, if you have it
	// (Leave as-is if already wired; this is illustrative.)
	// c.tel.RecordExporterArcPermitsInUse(int64(c.st.inFlight), c.attrs...)
	c.mu.Unlock()
}

func (c *Controller) CurrentLimit() int {
	c.mu.Lock()
	defer c.mu.Unlock()
	return c.st.limit
}

func (c *Controller) PermitsInUse() int {
	c.pool.mu.Lock()
	defer c.pool.mu.Unlock()
	return c.pool.inUse
}

// Feedback reports a sample (RTT + classification) and releases the permit.
// It must be called exactly once for every StartRequest that has a corresponding Acquire=true.
func (c *Controller) Feedback(ctx context.Context, rtt time.Duration, success, isBackpressure bool) {
	// Ensure the permit is always released.
	if c.cfg.Enabled {
		// Release via the pool to match other Release implementations.
		c.pool.Release()
	}

	// No controller updates when disabled.
	if !c.cfg.Enabled {
		return
	}

	// RTT is provided by the caller.
	c.mu.Lock()
	defer c.mu.Unlock()

	// ===== existing in-flight-- =====
	if c.st.inFlight > 0 {
		c.st.inFlight--
	}

	// ===== robust-EWMA update with rtt when success =====
	if success {
		// Update EWMA using RTT in milliseconds as a float64
		ms := float64(rtt.Milliseconds())
		c.st.lastRTTMean, c.st.lastRTTDev = c.st.reMean.update(ms)
		if c.rttInst != nil {
			c.rttInst.Record(contextOrBG(ctx), rtt.Milliseconds(), c.syncAttrs)
		}
	}

	// Backpressure and failure accounting
	if isBackpressure {
		c.st.pressure = true
		if c.failuresInst != nil {
			c.failuresInst.Add(contextOrBG(ctx), 1, c.syncAttrs)
		}
	} else if !success {
		// Non-backpressure failures are also counted.
		if c.failuresInst != nil {
			c.failuresInst.Add(contextOrBG(ctx), 1, c.syncAttrs)
		}
	}

	// ===== periodic control step / AIMD =====
	now := time.Now()
	if now.Sub(c.st.periodStart) > c.st.periodDur {
		// Call the controlStep
		c.controlStep(ctx)

		// Update prev RTT stats *after* controlStep uses them
		c.st.prevRTTMean = c.st.lastRTTMean
		c.st.prevRTTDev = c.st.lastRTTDev

		// Reset for next period
		c.st.periodStart = now

		// Recompute next control interval from observed RTT, clamped
		if c.st.reMean.initialized() {
			// Use mean RTT + 1 deviation as the period duration
			newDur := time.Duration(c.st.lastRTTMean+c.st.lastRTTDev) * time.Millisecond
			c.st.periodDur = clampDur(minPeriod, maxPeriod, newDur)
		}
	}
}

// requiredCredits tunes how aggressively we add permits.
func requiredCredits(limit int) int {
	if limit <= 1 {
		return 1
	}
	if limit < 8 {
		return 2
	}
	if limit < 32 {
		return 3
	}
	return 4
}

func clampDur(minDur, maxDur, v time.Duration) time.Duration {
	if v < minDur {
		return minDur
	}
	if v > maxDur {
		return maxDur
	}
	return v
}

// contextOrBG returns the provided context or context.Background() when nil.
func contextOrBG(ctx context.Context) context.Context {
	if ctx != nil {
		return ctx
	}
	return context.Background()
}
