// Copyright The OpenTelemetry Authors
// SPDX-License-Identifier: Apache-2.0

// Code generated by "internal/cmd/pdatagen/main.go". DO NOT EDIT.
// To regenerate this file run "make genpdata".

package internal

import (
	"encoding/binary"
	"fmt"
	"math"
	"sync"
	"unsafe"

	"go.opentelemetry.io/collector/pdata/internal/json"
	"go.opentelemetry.io/collector/pdata/internal/proto"
)

type AnyValue struct {
	Value    proto.OneOf
	metadata uint64
}

var protoPoolAnyValue = sync.Pool{
	New: func() any {
		return &AnyValue{}
	},
}

func NewAnyValue() *AnyValue {
	if !UseProtoPooling.IsEnabled() {
		return &AnyValue{}
	}
	return protoPoolAnyValue.Get().(*AnyValue)
}

func DeleteAnyValue(orig *AnyValue, nullable bool) {
	if orig == nil {
		return
	}

	if !UseProtoPooling.IsEnabled() {
		orig.Reset()
		return
	}
	switch orig.ValueType() {
	case AnyValueValueTypeStringValue:

	case AnyValueValueTypeIntValue:

	case AnyValueValueTypeDoubleValue:

	case AnyValueValueTypeBoolValue:

	case AnyValueValueTypeKvlistValue:
		DeleteKeyValueList(orig.KvlistValue(), true)
		orig.ResetValue()
	case AnyValueValueTypeArrayValue:
		DeleteArrayValue(orig.ArrayValue(), true)
		orig.ResetValue()
	case AnyValueValueTypeBytesValue:

	}
	orig.Reset()
	if nullable {
		protoPoolAnyValue.Put(orig)
	}
}

func CopyAnyValue(dest, src *AnyValue) *AnyValue {
	// If copying to same object, just return.
	if src == dest {
		return dest
	}

	if src == nil {
		return nil
	}

	if dest == nil {
		dest = NewAnyValue()
	}
	switch src.ValueType() {
	case AnyValueValueTypeEmpty:
		dest.ResetValue()
	case AnyValueValueTypeStringValue:
		dest.SetStringValue(src.StringValue())

	case AnyValueValueTypeIntValue:
		dest.SetIntValue(src.IntValue())

	case AnyValueValueTypeDoubleValue:
		dest.SetDoubleValue(src.DoubleValue())

	case AnyValueValueTypeBoolValue:
		dest.SetBoolValue(src.BoolValue())

	case AnyValueValueTypeKvlistValue:
		ov := NewKeyValueList()
		CopyKeyValueList(ov, src.KvlistValue())
		dest.SetKvlistValue(ov)

	case AnyValueValueTypeArrayValue:
		ov := NewArrayValue()
		CopyArrayValue(ov, src.ArrayValue())
		dest.SetArrayValue(ov)

	case AnyValueValueTypeBytesValue:
		dest.SetBytesValue(src.BytesValue())

	}

	return dest
}

func CopyAnyValueSlice(dest, src []AnyValue) []AnyValue {
	var newDest []AnyValue
	if cap(dest) < len(src) {
		newDest = make([]AnyValue, len(src))
	} else {
		newDest = dest[:len(src)]
		// Cleanup the rest of the elements so GC can free the memory.
		// This can happen when len(src) < len(dest) < cap(dest).
		for i := len(src); i < len(dest); i++ {
			DeleteAnyValue(&dest[i], false)
		}
	}
	for i := range src {
		CopyAnyValue(&newDest[i], &src[i])
	}
	return newDest
}

func CopyAnyValuePtrSlice(dest, src []*AnyValue) []*AnyValue {
	var newDest []*AnyValue
	if cap(dest) < len(src) {
		newDest = make([]*AnyValue, len(src))
		// Copy old pointers to re-use.
		copy(newDest, dest)
		// Add new pointers for missing elements from len(dest) to len(srt).
		for i := len(dest); i < len(src); i++ {
			newDest[i] = NewAnyValue()
		}
	} else {
		newDest = dest[:len(src)]
		// Cleanup the rest of the elements so GC can free the memory.
		// This can happen when len(src) < len(dest) < cap(dest).
		for i := len(src); i < len(dest); i++ {
			DeleteAnyValue(dest[i], true)
			dest[i] = nil
		}
		// Add new pointers for missing elements.
		// This can happen when len(dest) < len(src) < cap(dest).
		for i := len(dest); i < len(src); i++ {
			newDest[i] = NewAnyValue()
		}
	}
	for i := range src {
		CopyAnyValue(newDest[i], src[i])
	}
	return newDest
}

func (orig *AnyValue) Reset() {
	*orig = AnyValue{}
}

// MarshalJSON marshals all properties from the current struct to the destination stream.
func (orig *AnyValue) MarshalJSON(dest *json.Stream) {
	dest.WriteObjectStart()
	switch orig.ValueType() {
	case AnyValueValueTypeStringValue:
		dest.WriteObjectField("stringValue")
		dest.WriteString(orig.StringValue())
	case AnyValueValueTypeIntValue:
		dest.WriteObjectField("intValue")
		dest.WriteInt64(orig.IntValue())
	case AnyValueValueTypeDoubleValue:
		dest.WriteObjectField("doubleValue")
		dest.WriteFloat64(orig.DoubleValue())
	case AnyValueValueTypeBoolValue:
		dest.WriteObjectField("boolValue")
		dest.WriteBool(orig.BoolValue())
	case AnyValueValueTypeKvlistValue:
		dest.WriteObjectField("kvlistValue")
		orig.KvlistValue().MarshalJSON(dest)
	case AnyValueValueTypeArrayValue:
		dest.WriteObjectField("arrayValue")
		orig.ArrayValue().MarshalJSON(dest)
	case AnyValueValueTypeBytesValue:
		dest.WriteObjectField("bytesValue")
		dest.WriteBytes(orig.BytesValue())
	}
	dest.WriteObjectEnd()
}

// UnmarshalJSON unmarshals all properties from the current struct from the source iterator.
func (orig *AnyValue) UnmarshalJSON(iter *json.Iterator) {
	for f := iter.ReadObject(); f != ""; f = iter.ReadObject() {
		switch f {

		case "stringValue", "string_value":
			orig.SetStringValue(iter.ReadString())
		case "intValue", "int_value":
			orig.SetIntValue(iter.ReadInt64())
		case "doubleValue", "double_value":
			orig.SetDoubleValue(iter.ReadFloat64())
		case "boolValue", "bool_value":
			orig.SetBoolValue(iter.ReadBool())
		case "kvlistValue", "kvlist_value":
			{
				ov := NewKeyValueList()
				ov.UnmarshalJSON(iter)
				orig.SetKvlistValue(ov)
			}
		case "arrayValue", "array_value":
			{
				ov := NewArrayValue()
				ov.UnmarshalJSON(iter)
				orig.SetArrayValue(ov)
			}
		case "bytesValue", "bytes_value":
			{
				orig.SetBytesValue(iter.ReadBytes())
			}

		default:
			iter.Skip()
		}
	}
}

func (orig *AnyValue) SizeProto() int {
	var n int
	var l int
	_ = l
	switch orig.ValueType() {
	case AnyValueValueTypeEmpty:
		break
	case AnyValueValueTypeStringValue:
		l = len(orig.StringValue())
		n += 1 + proto.Sov(uint64(l)) + l
	case AnyValueValueTypeIntValue:

		n += 1 + proto.Sov(uint64(orig.IntValue()))
	case AnyValueValueTypeDoubleValue:

		n += 9
	case AnyValueValueTypeBoolValue:

		n += 2
	case AnyValueValueTypeKvlistValue:
		l = orig.KvlistValue().SizeProto()
		n += 1 + proto.Sov(uint64(l)) + l
	case AnyValueValueTypeArrayValue:
		l = orig.ArrayValue().SizeProto()
		n += 1 + proto.Sov(uint64(l)) + l
	case AnyValueValueTypeBytesValue:
		l = len(orig.BytesValue())
		n += 1 + proto.Sov(uint64(l)) + l
	}
	return n
}

func (orig *AnyValue) MarshalProto(buf []byte) int {
	pos := len(buf)
	var l int
	_ = l
	switch orig.ValueType() {
	case AnyValueValueTypeStringValue:
		{
			val := orig.StringValue()
			l = len(val)
			pos -= l
			copy(buf[pos:], val)
			pos = proto.EncodeVarint(buf, pos, uint64(l))
			pos--
			buf[pos] = 0xa
		}
	case AnyValueValueTypeIntValue:
		pos = proto.EncodeVarint(buf, pos, uint64(orig.IntValue()))
		pos--
		buf[pos] = 0x18

	case AnyValueValueTypeDoubleValue:
		pos -= 8
		binary.LittleEndian.PutUint64(buf[pos:], math.Float64bits(orig.DoubleValue()))
		pos--
		buf[pos] = 0x21

	case AnyValueValueTypeBoolValue:
		pos--
		if orig.BoolValue() {
			buf[pos] = 1
		} else {
			buf[pos] = 0
		}
		pos--
		buf[pos] = 0x10

	case AnyValueValueTypeKvlistValue:
		l = orig.KvlistValue().MarshalProto(buf[:pos])
		pos -= l
		pos = proto.EncodeVarint(buf, pos, uint64(l))
		pos--
		buf[pos] = 0x32

	case AnyValueValueTypeArrayValue:
		l = orig.ArrayValue().MarshalProto(buf[:pos])
		pos -= l
		pos = proto.EncodeVarint(buf, pos, uint64(l))
		pos--
		buf[pos] = 0x2a

	case AnyValueValueTypeBytesValue:
		{
			val := orig.BytesValue()
			l = len(val)
			pos -= l
			copy(buf[pos:], val)
			pos = proto.EncodeVarint(buf, pos, uint64(l))
			pos--
			buf[pos] = 0x3a
		}
	}
	return len(buf) - pos
}

func (orig *AnyValue) UnmarshalProto(buf []byte) error {
	var err error
	var fieldNum int32
	var wireType proto.WireType

	l := len(buf)
	pos := 0
	for pos < l {
		// If in a group parsing, move to the next tag.
		fieldNum, wireType, pos, err = proto.ConsumeTag(buf, pos)
		if err != nil {
			return err
		}
		switch fieldNum {

		case 1:
			if wireType != proto.WireTypeLen {
				return fmt.Errorf("proto: wrong wireType = %d for field StringValue", wireType)
			}
			var length int
			length, pos, err = proto.ConsumeLen(buf, pos)
			if err != nil {
				return err
			}
			startPos := pos - length
			orig.SetStringValue(string(buf[startPos:pos]))

		case 3:
			if wireType != proto.WireTypeVarint {
				return fmt.Errorf("proto: wrong wireType = %d for field IntValue", wireType)
			}
			var num uint64
			num, pos, err = proto.ConsumeVarint(buf, pos)
			if err != nil {
				return err
			}
			orig.SetIntValue(int64(num))

		case 4:
			if wireType != proto.WireTypeI64 {
				return fmt.Errorf("proto: wrong wireType = %d for field DoubleValue", wireType)
			}
			var num uint64
			num, pos, err = proto.ConsumeI64(buf, pos)
			if err != nil {
				return err
			}
			orig.SetDoubleValue(math.Float64frombits(num))

		case 2:
			if wireType != proto.WireTypeVarint {
				return fmt.Errorf("proto: wrong wireType = %d for field BoolValue", wireType)
			}
			var num uint64
			num, pos, err = proto.ConsumeVarint(buf, pos)
			if err != nil {
				return err
			}
			orig.SetBoolValue(num != 0)

		case 6:
			if wireType != proto.WireTypeLen {
				return fmt.Errorf("proto: wrong wireType = %d for field KvlistValue", wireType)
			}
			var length int
			length, pos, err = proto.ConsumeLen(buf, pos)
			if err != nil {
				return err
			}
			startPos := pos - length
			ov := NewKeyValueList()
			err = ov.UnmarshalProto(buf[startPos:pos])
			if err != nil {
				return err
			}
			orig.SetKvlistValue(ov)

		case 5:
			if wireType != proto.WireTypeLen {
				return fmt.Errorf("proto: wrong wireType = %d for field ArrayValue", wireType)
			}
			var length int
			length, pos, err = proto.ConsumeLen(buf, pos)
			if err != nil {
				return err
			}
			startPos := pos - length
			ov := NewArrayValue()
			err = ov.UnmarshalProto(buf[startPos:pos])
			if err != nil {
				return err
			}
			orig.SetArrayValue(ov)

		case 7:
			if wireType != proto.WireTypeLen {
				return fmt.Errorf("proto: wrong wireType = %d for field BytesValue", wireType)
			}
			var length int
			length, pos, err = proto.ConsumeLen(buf, pos)
			if err != nil {
				return err
			}
			startPos := pos - length
			var copyBuf []byte
			if length != 0 {
				copyBuf = make([]byte, length)
				copy(copyBuf, buf[startPos:pos])
			}
			orig.SetBytesValue(copyBuf)

		default:
			pos, err = proto.ConsumeUnknown(buf, pos, wireType)
			if err != nil {
				return err
			}
		}
	}
	return nil
}

type AnyValueValueType int32

const (
	AnyValueValueTypeEmpty AnyValueValueType = iota
	AnyValueValueTypeStringValue
	AnyValueValueTypeIntValue
	AnyValueValueTypeDoubleValue
	AnyValueValueTypeBoolValue
	AnyValueValueTypeKvlistValue
	AnyValueValueTypeArrayValue
	AnyValueValueTypeBytesValue
)

const (
	startBitAnyValueValue             = uint64(0)
	maskAnyValueValue                 = uint64(7)
	reversedMaskAnyValueValue         = ^maskAnyValueValue
	fieldMaskAnyValueValueStringValue = uint64(1 << startBitAnyValueValue)
	fieldMaskAnyValueValueIntValue    = uint64(2 << startBitAnyValueValue)
	fieldMaskAnyValueValueDoubleValue = uint64(3 << startBitAnyValueValue)
	fieldMaskAnyValueValueBoolValue   = uint64(4 << startBitAnyValueValue)
	fieldMaskAnyValueValueKvlistValue = uint64(5 << startBitAnyValueValue)
	fieldMaskAnyValueValueArrayValue  = uint64(6 << startBitAnyValueValue)
	fieldMaskAnyValueValueBytesValue  = uint64(7 << startBitAnyValueValue)
)

func (m *AnyValue) ValueType() AnyValueValueType {
	val := (m.metadata & maskAnyValueValue) >> startBitAnyValueValue
	return AnyValueValueType(val)
}

func (m *AnyValue) ResetValue() {
	m.Value.Reset()
	m.metadata &= reversedMaskAnyValueValue
}
func (m *AnyValue) SetStringValue(value string) {
	m.Value.SetString(value)
	m.metadata &= reversedMaskAnyValueValue
	m.metadata |= fieldMaskAnyValueValueStringValue
}

func (m *AnyValue) StringValue() string {
	if m.ValueType() != AnyValueValueTypeStringValue {
		return ""
	}
	return (string)(m.Value.String())
}

func (m *AnyValue) SetIntValue(value int64) {
	m.Value.SetInt(uint64(value))
	m.metadata &= reversedMaskAnyValueValue
	m.metadata |= fieldMaskAnyValueValueIntValue
}

func (m *AnyValue) IntValue() int64 {
	if m.ValueType() != AnyValueValueTypeIntValue {
		return int64(0)
	}
	return (int64)(m.Value.Int())
}

func (m *AnyValue) SetDoubleValue(value float64) {
	m.Value.SetFloat(float64(value))
	m.metadata &= reversedMaskAnyValueValue
	m.metadata |= fieldMaskAnyValueValueDoubleValue
}

func (m *AnyValue) DoubleValue() float64 {
	if m.ValueType() != AnyValueValueTypeDoubleValue {
		return float64(0)
	}
	return (float64)(m.Value.Float())
}

func (m *AnyValue) SetBoolValue(value bool) {
	m.Value.SetBool(value)
	m.metadata &= reversedMaskAnyValueValue
	m.metadata |= fieldMaskAnyValueValueBoolValue
}

func (m *AnyValue) BoolValue() bool {
	if m.ValueType() != AnyValueValueTypeBoolValue {
		return false
	}
	return (bool)(m.Value.Bool())
}

func (m *AnyValue) SetKvlistValue(value *KeyValueList) {
	m.Value.SetMessage(unsafe.Pointer(value))
	m.metadata &= reversedMaskAnyValueValue
	m.metadata |= fieldMaskAnyValueValueKvlistValue
}

func (m *AnyValue) KvlistValue() *KeyValueList {
	if m.ValueType() != AnyValueValueTypeKvlistValue {
		return nil
	}
	return (*KeyValueList)(m.Value.Message())
}

func (m *AnyValue) SetArrayValue(value *ArrayValue) {
	m.Value.SetMessage(unsafe.Pointer(value))
	m.metadata &= reversedMaskAnyValueValue
	m.metadata |= fieldMaskAnyValueValueArrayValue
}

func (m *AnyValue) ArrayValue() *ArrayValue {
	if m.ValueType() != AnyValueValueTypeArrayValue {
		return nil
	}
	return (*ArrayValue)(m.Value.Message())
}

func (m *AnyValue) SetBytesValue(value []byte) {
	m.Value.SetBytes(&value)
	m.metadata &= reversedMaskAnyValueValue
	m.metadata |= fieldMaskAnyValueValueBytesValue
}

func (m *AnyValue) BytesValue() []byte {
	if m.ValueType() != AnyValueValueTypeBytesValue {
		return nil
	}
	return *m.Value.Bytes()
}

func (m *AnyValue) BytesValuePtr() *[]byte {
	if m.ValueType() != AnyValueValueTypeBytesValue {
		return nil
	}
	return m.Value.Bytes()
}

func GenTestAnyValue() *AnyValue {
	orig := NewAnyValue()
	orig.SetStringValue("test_stringvalue")
	return orig
}

func GenTestAnyValuePtrSlice() []*AnyValue {
	orig := make([]*AnyValue, 5)
	orig[0] = NewAnyValue()
	orig[1] = GenTestAnyValue()
	orig[2] = NewAnyValue()
	orig[3] = GenTestAnyValue()
	orig[4] = NewAnyValue()
	return orig
}

func GenTestAnyValueSlice() []AnyValue {
	orig := make([]AnyValue, 5)
	orig[1] = *GenTestAnyValue()
	orig[3] = *GenTestAnyValue()
	return orig
}
