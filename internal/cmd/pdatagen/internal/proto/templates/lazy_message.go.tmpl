// Copyright The OpenTelemetry Authors
// SPDX-License-Identifier: Apache-2.0

// Code generated by "internal/cmd/pdatagen/main.go". DO NOT EDIT.
// To regenerate this file run "make genpdata".

package internal

import (
    {{ range $index, $element := .imports -}}
    {{ $element }}
    {{ end }}
)

{{ .description }}
type Lazy{{ .messageName }} struct {
    {{ .messageName }}
    bytes []byte
}

var (
    protoPoolLazy{{ .messageName }} = sync.Pool{
        New: func() any {
            return &Lazy{{ .messageName }}{}
        },
    }
)


func NewLazy{{ .messageName }}() *Lazy{{ .messageName }} {
    if !UseProtoPooling.IsEnabled() {
        return &Lazy{{ .messageName }}{}
    }
    return protoPoolLazy{{ .messageName }}.Get().(*Lazy{{ .messageName }})
}

func DeleteLazy{{ .messageName }}(orig *Lazy{{ .messageName }}, nullable bool) {
    if orig == nil {
        return
    }

    if !UseProtoPooling.IsEnabled() {
        orig.Reset()
        return
    }

    Delete{{ .messageName }}(&orig.{{ .messageName }}, false)

    orig.Reset()
    if nullable {
        protoPoolLazy{{ .messageName }}.Put(orig)
    }
}

func CopyLazy{{ .messageName }}(dest, src *Lazy{{ .messageName }}) *Lazy{{ .messageName }}{
    // If copying to same object, just return.
    if src == dest {
        return dest
    }

    if src == nil {
        return nil;
    }

    if dest == nil {
        dest = NewLazy{{ .messageName }}();
    }

    Copy{{ .messageName }}(&dest.{{ .messageName }}, &src.{{ .messageName }})
    dest.bytes = src.bytes

    return dest
}

func CopyLazy{{ .messageName }}Slice(dest, src []Lazy{{ .messageName }}) []Lazy{{ .messageName }} {
    var newDest []Lazy{{ .messageName }}
    if cap(dest) < len(src) {
        newDest = make([]Lazy{{ .messageName }}, len(src))
    } else {
        newDest = dest[:len(src)]
        // Cleanup the rest of the elements so GC can free the memory.
        // This can happen when len(src) < len(dest) < cap(dest).
        for i := len(src); i < len(dest); i++ {
            DeleteLazy{{ .messageName }}(&dest[i], false)
        }
    }
    for i := range src {
        CopyLazy{{ .messageName }}(&newDest[i], &src[i])
    }
    return newDest
}

func CopyLazy{{ .messageName }}PtrSlice(dest, src []*Lazy{{ .messageName }}) []*Lazy{{ .messageName }} {
    var newDest []*Lazy{{ .messageName }}
    if cap(dest) < len(src) {
        newDest = make([]*Lazy{{ .messageName }}, len(src))
        // Copy old pointers to re-use.
        copy(newDest, dest)
        // Add new pointers for missing elements from len(dest) to len(srt).
        for i := len(dest); i < len(src); i++ {
            newDest[i] = NewLazy{{ .messageName }}()
        }
    } else {
        newDest = dest[:len(src)]
        // Cleanup the rest of the elements so GC can free the memory.
        // This can happen when len(src) < len(dest) < cap(dest).
        for i := len(src); i < len(dest); i++ {
            DeleteLazy{{ .messageName }}(dest[i], true)
            dest[i] = nil
        }
        // Add new pointers for missing elements.
        // This can happen when len(dest) < len(src) < cap(dest).
        for i := len(dest); i < len(src); i++ {
            newDest[i] = NewLazy{{ .messageName }}()
        }
    }
    for i := range src {
        CopyLazy{{ .messageName }}(newDest[i], src[i])
    }
    return newDest
}


func (orig *Lazy{{ .messageName }}) Reset() {
    *orig = Lazy{{ .messageName }}{}
}

// MarshalJSON marshals all properties from the current struct to the destination stream.
func (orig *Lazy{{ .messageName }}) MarshalJSON(dest *json.Stream) {
    orig.{{ .messageName }}.MarshalJSON(dest)
}

// UnmarshalJSON unmarshals all properties from the current struct from the source iterator.
func (orig *Lazy{{ .messageName }}) UnmarshalJSON(iter *json.Iterator) {
    orig.{{ .messageName }}.UnmarshalJSON(iter)
}

func (orig *Lazy{{ .messageName }}) SizeProto() int {
    return orig.{{ .messageName }}.SizeProto()
}

func (orig *Lazy{{ .messageName }}) MarshalProto(buf []byte) int {
    return orig.{{ .messageName }}.MarshalProto(buf)
}

func (orig *Lazy{{ .messageName }}) UnmarshalProto(buf []byte) error {
    return orig.UnmarshalProtoOpts(buf, &pdata.DefaultUnmarshalOptions)
}

func (orig *Lazy{{ .messageName }}) UnmarshalProtoOpts(buf []byte, opts *pdata.UnmarshalOptions) error {
    if !opts.LazyDecoding {
        return orig.{{ .messageName }}.UnmarshalProtoOpts(buf, opts)
    }
    orig.bytes = buf
    orig.{{ .messageName }}.Reset()
    return nil
}

func (orig *Lazy{{ .messageName }}) FinishUnmarshal(buf *{{ .messageName }}) (*{{ .messageName }}, error) {
    if len(orig.bytes) == 0 {
        return &orig.{{ .messageName }}, nil
    }
    err := buf.UnmarshalProto(orig.bytes)
    return buf, err
}

func GenTestLazy{{ .messageName }}() *Lazy{{ .messageName }} {
    orig := NewLazy{{ .messageName }}()
    orig.{{ .messageName }} = *GenTest{{ .messageName }}()
    return orig
}

func GenTestLazy{{ .messageName }}PtrSlice() []*Lazy{{ .messageName }} {
    orig := make([]*Lazy{{ .messageName }}, 5)
    orig[0] = NewLazy{{ .messageName }}()
    orig[1] = GenTestLazy{{ .messageName }}()
    orig[2] = NewLazy{{ .messageName }}()
    orig[3] = GenTestLazy{{ .messageName }}()
    orig[4] = NewLazy{{ .messageName }}()
    return orig
}

func GenTestLazy{{ .messageName }}Slice() []Lazy{{ .messageName }} {
    orig := make([]Lazy{{ .messageName }}, 5)
    orig[1] = *GenTestLazy{{ .messageName }}()
    orig[3] = *GenTestLazy{{ .messageName }}()
    return orig
}
